\section{Temporal Metadata Model} \label{section:temporal}

In this section, we extend our metadata model with a temporal dimension that
enables the applications in Section~\ref{section:motivation}. To do this effectively, we first
discuss our notions of \emph{time} and how to mitigate discrepancies between client and server.
We then examine established temporal data models such as the Bitemporal Conceptual Data Model (BCDM).
Because most research into temporal data models has been conerned with relational or spatial models,
these models are more complicated than needed for a simple EAV table.

\begin{itemize}
\item then start talking about temporal query languages?
\item temporal query language tquel~\cite{snodgrass1987temporal}
\item tsql2~\cite{snodgrass2012tsql2}
\item tquery~\cite{kahn1991tquery}
\item differentiate from continuous query languages like CQL~\cite{arasu2006cql}
\end{itemize}

\subsection{What is Time?}

There are two flavors of time that temporal database must deal with:
\emph{valid time} and \emph{transaction time}~\cite{jensen1999temporal}\cite{jensen1996semantics}. 

\textbf{Valid time} is the extent for which a given \emph{fact} is true. For
our model, a fact is the association of a key-value pair with a stream,
changing the value associated with a stream's key, or removing a key-value pair
from a stream's metadata. Valid time is expressed in terms of real-world time
and is how metadata facts are aligned with timeseries data, which is stored
using real-world time. Because valid time is the coordinating aspect across the
two databases (timeseries and metadata), it is also the point of interaction
for consumers of data.

A fact's valid time can be qualified either by a single time (``start'') or by
a duration (``start'' and ``end''). Duration-based facts are used in most of
the established relational models (I believe because they make temporal joins
easier to reason about).  The use of a start-time lends itself to diff-based
storage, where facts for each \texttt{<uuid, key>} pair are considered valid
until a new fact is written for the same \texttt{<uuid, key>} pair. This also
removes the need to invalidate past facts, which is a drawback of the
bitemporal model (BCDM).

\textbf{Transaction time} is a logical timestamp that represents when a fact
takes place in relation to other facts. In a temporal database where all
entries are made at the current time, transaction time can be conflated with
valid time, but if the database allows retroactive inserts, then these two
times must be separate. In our demo implementation, transaction time is made
implicit through the use of transactions on the underlying database. Unlike
valid times, which maybe added in the past, transaction times are strictly
monotonic.

A temporal database must decide whether or not to make these timestamps
explicit in the representation and query interface.  While these two views of
time are orthogonal~\cite{snodgrass1986temporal}, some databases such as
POSTGRES~\cite{stonebraker1990implementation} conflate the two into transaction
time and only maintain a history of changes so far as to resolve concurrent
transactions. Transaction times are useful for ordering incoming operations,
but do not need to be factored into the query model. Thus, our model makes
valid timestamps explicit in the storage and retrieval of facts, but
transaction times are kept internal to the DBMS.

\if 0
have a figure here? start-time vs duration time?
\fi

\subsection{Temporal Data Models}

The \textbf{Temporally Oriented Data Model}~\cite{ariav1986temporally} (TODM)
stores temporal data along the 3 dimensions of objects, attributes and
time. TODM makes an assumption of temporal isomorphism, that is, ``there is a tight
correspondence between the database and the temporally concurrent reality it is
aimed to capture.''\cite{ariav1986temporally}. This seems to preclude
insertions into the past, but TODM does use this restriction to avoid
penalizing queries interested in the most current version of an object, which
is a design goal for our approach as well. We wish to preserve the 3-dimensioanl
relation of object (UUID), attribute (key-value) and time, but with valid
and transactional times decoupled.

\textbf{The Generalized Model for a Relational Temporal Database}~\cite{gadia1988generalized} proposes a two-dimensional
model that preserves both real world (valid) and transactional timestamps of a
tuple, but is directed towards fully relational representations of data.  The
disadvantage of the model -- for a fully general temporal relational database
-- is that it cannot express valid times that occur after the transaction
time\footnote{This is not a feature that our model needs to support}.

\todo{think abou this next part}
Generalized Model for a Relational Temporal
Database~\cite{gadia1988generalized} makes the observation that ``intervals are
not closed under union, intersection and complementation, and thus are not
adequate to model natural language queries involving `or', `and' and `not'.''

The \textbf{Historical Database Management System} (HDBMS)
model~\cite{sarda1990extensions} uses an extended relational model, in which
all tuples are stored normally but with the addition of interval timestamps.
The associated query language, HSQL, uses this extension for operations such as
time-based joins. 

A point of major simplification in our model is that we do not need to directly
support joins based on time, meaning we can retain all of our relational
algebra, and use simple qualifiers on time instants and extents to further
restrict the evaluations of their associated predicates.

\cite{jensen1994unifying} proposes the \textbf{Bitemporal conceptual data
model} (BCDM), which stores relations with 4 additional columns: valid
start/end time and transaction start/end time. However, due to the complexity
(and completeness) of the model, \cite{jensen1999temporal} asserts that there
is much work to be done on evaluating the performance of the extended
relational algebra as well as how to efficiently implement a compliant
database.

\begin{itemize}
%\item BCDM bitemporal conceptual data model: only captures when facts are valid in reality and when stored in database~\cite{jensen1996semantics}\cite{jensen1994unifying}
\item incremental relational temporal model: \cite{jensen1991incremental}
\item relational algebra accounts for transaction time, evolution of contents as well as schema~\cite{mckenzie1990schema}
\end{itemize}

\subsection{Proposed Temporal Query Language}

Figure~\ref{fig:temporalgrammar} contains a simplified grammar of our proposed temporal query language.

\setlength{\grammarindent}{8em}
\setlength{\grammarparsep}{4pt}
\begin{figure}
\centering
\begin{grammar}
<query> := `select' <selectClause> `where' <whereClause>

<selectClause> := <selectTerm>
\alt <selectTerm> `,' <selectClause>

<selectTerm> := <selectTermValue>
\alt `FIRST' <selectTermValue>
\alt `LAST' <selectTermValue>
\alt `ALL' <selectTermValue>
\alt <selectTermValue> `AT' <time>
\alt <selectTermValue> `IAFTER' <time>
\alt <selectTermValue> `IBEFORE' <time>
\alt <selectTermValue> `AFTER' <time>
\alt <selectTermValue> `BEFORE' <time>
\alt <selectTermValue> `IN' `(' <time> `,' <time> `)'

<selectTermValue> := <lvalue>
\alt `*'
\alt `DISTINCT' <lvalue>
\alt `DATA IN' `(' <time> `,' <time> `)'
\alt `DATA BEFORE' <time>
\alt `DATA AFTER' <time>

<whereClause> := <whereTerm> `AND' <whereClause>
\alt <whereTerm> `OR' <whereClause>
\alt `NOT' <whereClause>
\alt `(' <whereClause> `)'
\alt <whereTerm>

<whereTerm> := <predicate>
\alt <predicate> <temporalPredicate>

<predicate> := <lvalue> `LIKE' <rvalue>
\alt <lvalue> `=' <rvalue>
\alt <lvalue> `!=' <rvalue>
\alt `HAS' <lvalue>

<temporalPredicate> := `HAPPENS IN' `(' <time> `,' <time> `)'
\alt `HAPPENS BEFORE' <time>
\alt `HAPPENS AFTER' <time>
\alt `AT' <time>
\alt `FOR' `(' <time> `,' <time> `)'

<rvalue> := <string>
\alt <number>
\alt <regex>
\alt <uuid>

<lvalue> := <string>
\end{grammar}
\caption{Simplified grammar for the \emph{temporal} query language over timeseries and metadata}
\label{fig:temporalgrammar}
\end{figure}

%[39, 52, 53, 74]

%\begin{itemize}
%\item Discuss current tmporal data models
%    \begin{itemize}
%    \item TODO: make this list
%    \item OURS: how to augment with time: add column to EAV
%    \end{itemize}
%\item discuss sql vs nosql for demo implementation?
%    \begin{itemize}
%    \item SQL more suited for diffs?
%    \item NoSQL more suited for replication?
%    \end{itemize}
%\end{itemize}
%
Some related work:
\begin{itemize}
\item $<tt, vt>$ (timestamp, validtime) for temporal data~\cite{jensen1999temporal},
also stratum vs integrated approaches for implementing temporal databases
\item extending relational algebra for temporal data?~\cite{lorentzos1988extending}
\item list of temporal terms~\cite{dyreson1994consensus}
\end{itemize}
